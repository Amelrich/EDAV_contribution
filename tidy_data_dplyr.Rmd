# Revue détaillée : Tidy Data & dplyr {#tidy}

![](images/banners/banner_tidy_data_dplyr.png)
*Ce chapitre est à l'origine une contribution communautaire de [akshatapatel](https://github.com/akshatapatel){target="_blank"}*

*En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur [contribuer au repo](contribute.html).*

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
class(biopsy)

library(dplyr)
```

## Vue d'ensemble

Cet exemple présente certains travaux avec le jeu de données `biopsy` en utilisant les fonctions de `dplyr` pour obtenir un tidy dataset.

### Les packages 

* [`dplyr`](https://www.rdocumentation.org/packages/dplyr){target="_blank"}
* [`MASS`](https://www.rdocumentation.org/packages/MASS/versions/7.3-51.1){target="_blank"}
* [`tidyr`](https://www.rdocumentation.org/packages/tidyr/versions/0.8.2){target="_blank"}


## Installer les packages
Écrivez le statements suivant dans le console:

* `install.packages('dplyr')`
* `install.packages('ggplot2')`
* `install.packages('tidyr')`
* `install.packages('MASS')` 

**Remarque**: Les trois premiers packages font partie de **tidyverse**, une collection de packages utiles dans R, qui peuvent tous être installés à l'aide de `install.packages('tidyverse')`.

`dplyr` est utilisé pour le formattage et la transformation des données dans un dataframe. Le "d" dans "dplyr" signifie "dataframes" qui est la structure de données la plus utilisée pour stocker des jeux de données dans R.

## Voir les données
Commençons par charger le package afin que nous puissions obtenir les données dans des dataframes :
```{r, include=TRUE}
#loading the dplyr library
library(dplyr)

#loading data from MASS:biopsy
library(MASS)
class(biopsy)
```

```{r import_data}
#glimpse is a part of the dplyr package
glimpse(biopsy)

head(biopsy)
```

## Qu'est ce qu'une Tidy data?
**Qu'est-ce que cela signifie pour vos données d'être *tidy* ?**

**Tidy data** est un format normalisé et constitue une manière cohérente d'organiser vos données dans R.

Voici la définition d'une Tidy Data donnée par Hadley Wickham :

>Un ensemble de données est en désordre ou ordonné selon la manière dont les lignes, les colonnes et les tableaux correspondent aux observations, aux variables et aux types. Une tidy data :
>
>* Chaque variable forme une colonne.
>
>* Chaque observation forme une ligne.
>
>* Chaque unité d'observation est une valeur dans la table.
>
*Voir [r4ds on tidy data](https://r4ds.had.co.nz/tidy-data.html){target="_blank"} pour plus d'info.*

**Quels sont les avantages de tidy data?**

* Uniformité : il est plus facile d'apprendre les outils qui travaillent avec les données car ils disposent d'un moyen cohérent de stockage des données.

* La plupart des built-in R functions travaillent avec des vecteurs de valeurs. Ainsi, avoir des variables en tant que columns/vectors permet à R’s vectorized nature de briller.

**Pouvez-vous observer et dire pourquoi ces données sont en désordre?**

* Les noms de columns tels que V1, V2 ne sont pas intuitifs dans leur contenu; bon signe c'est untidy.

* Ce ne sont pas des variables différentes, mais des valeurs d'une variable commune.

Nous allons maintenant voir comment transformer nos données en utilisant `dplyr` functions et ensuite voir comment tidy notre transformed data.

## Tibbles

Un **tibble** est une ré-imaginaire moderne du data frame.

Ceci est particulièrement utile pour les grands ensembles de données car * il n'imprime que les premières lignes *. Cela vous aide à faire face plus tôt aux problèmes, ce qui vous permet de nettoyer le code.
```{r, include=TRUE}
# Converting a df to a tibble
biopsy <- tbl_df(biopsy)
biopsy
```


## Test pour missing values

```{r, include=TRUE}
# Number of missing values in each column in the data frame
colSums(is.na(biopsy))
```

L'ensemble de données contient des valeurs manquantes qui doivent être traitées.

## Recode the missing values
Une façon de traiter les valeurs manquantes consiste à les recoder avec la moyenne de toutes les autres valeurs de cette colonne:
```{r, include=TRUE}
#change all the NAs to mean of the column
biopsy$V6[is.na(biopsy$V6)] <- mean(biopsy$V6, na.rm = TRUE)
colSums(is.na(biopsy))
```

Consultez notre chapitre sur [time series with missing data](missingTS.html) pour plus d'informations sur la gestion des données manquantes.

## Data wrangling verbs
Voici les verbes de functions les plus couramment utilisés qui aident les données wrangle et summarize:

* Rename
* Select
* Mutate
* Filter
* Arrange
* Summarize
* Group_by

**Select** et **mutate** functions manipulez le *variable* (les columns du data frame). **Filter** et **arrange** functions manipulez le *observations* (les rows des données) ,alors que le **summarize** function manipulez *groups* d'observations.

Tous les `dplyr` functions travaillent sur une copie des données et renvoient une copie modifiée. Ils ne changent **pas** le data frame original. Si nous voulons accéder aux résultats par la suite, nous devons enregistrer la copie modifiée.
## Rename

Les noms des colonnes dans nos données biopsy sont très vagues et ne nous donnent pas la signification des valeurs de cette colonne. Nous devons modifier les noms de la colonne afin que le visualiseur puisse avoir une idée des valeurs auxquelles il fait référence.

```{r, include=TRUE}
rename(biopsy,
       thickness = V1,cell_size = V2,
       cell_shape = V3, marg_adhesion = V4,
       epithelial_cell_size = V5, bare_nuclei = V6,
       chromatin = V7, norm_nucleoli = V8, mitoses = V9)
```

Le tibble présenté ci-dessus n'est pas enregistré et ne peut plus être utilisé. Pour l'utiliser ensuite, nous l'enregistrons comme un nouveau tibble:
```{r, include=TRUE}
#saving the rename function output
biopsy_new<-rename(biopsy,
       thickness = V1,cell_size = V2,
       cell_shape = V3, marg_adhesion = V4,
       epithelial_cell_size = V5, bare_nuclei = V6,
       chromatin = V7, norm_nucleoli = V8, mitoses = V9)

head(biopsy_new,5)
```

Le `biopsy_new` data frame peut maintenant être utilisé pour d'autres manipulations.

## Select
**Select** renvoie un subset des données. Plus précisément, seules les colonnes spécifiées sont incluses.

Dans le biopsy data, nous n’avons pas besoin des variables "chromatin" et "mitoses". Alors, éliminons-les en utilisant un signe moins:
```{r, include=TRUE}
#selecting all except the columns chromatin and mitoses
biopsy_new<-select(biopsy_new,-chromatin,-mitoses)

head(biopsy_new,5)
```

## Mutate
Le **mutate** function crée de nouvelles variables à partir des variables déjà existantes et les ajoute à l'ensemble de données. Il indique que les données déjà contenues mais n’ont jamais été affichées.

Le "V6" variable contient les valeurs du bare nucleus de 1,00 à 10,00. Si nous voulons normalize la variable, nous pouvons utiliser le mutate function:
```{r, include=TRUE}
#normalize the bare nuclei values 
maximum_bare_nuclei<-max(biopsy_new$bare_nuclei,na.rm=TRUE)
biopsy_new<-mutate(biopsy_new,bare_nuclei=bare_nuclei/maximum_bare_nuclei)

head(biopsy_new,5)
```

## Filter
**Filter** est la fonction équivalente à la **select** pour les rows; il renvoie une copie modifiée qui ne contient que certaines rows.
Cette fonction *filters* rows en fonction du contenu et des conditions fournies dans son argument.
Le filter function prend le data frame comme premier argument. L'argument suivant contient un ou plusieurs tests logiques. Les rows/observations qui passent ces tests logiques sont retournés dans le résultat du filter function.

Pour notre exemple, nous voulons seulement les données des cellules de turmor dont l'épaisseur de la masse est supérieure à six car la plupart des tumeurs malignes ont cette épaisseur en regardant une parcelle de l'épaisseur de la masse en fonction de la taille des cellules tumorales regroupées par classe:
```{r, include=TRUE}
library(ggplot2)

ggplot(biopsy_new)+
  geom_point(aes(x=thickness,y=cell_size,color=class))+
  ggtitle("Plot of Clump Thickness Vs Tumor Cell Size")

```

```{r, include=TRUE}
#normalize the bare nuclei values 
biopsy_new<-filter(biopsy_new,thickness>5.5)

head(biopsy_new,5)
```


## Arrange
**Arrange** réordonne les rows des données en fonction de leur contenu dans l'ordre croissant par défaut.

Les médecins voudraient voir les données dans l'ordre de la taille de la tumeur.
```{r, include=TRUE}
#arrange in the order of V2:cell size
arrange(biopsy_new,cell_size)
```

Cela montre les données en ordre croissant de la taille de la cellule.

Pour organiser les lignes dans l'ordre décroissant de V2, nous ajoutons la fonction `desc ()` à la variable avant de la passer à arrangement.

```{r, include=TRUE}
#arrange in the order of V2:cell size in decreasing order
arrange(biopsy_new,desc(cell_size))
```

Comme vous pouvez le constater, plusieurs rows ont la même valeur de `V2:cell_size`. Pour rompre le lien, vous pouvez ajouter une autre variable à utiliser pour organiser lorsque la première variable a la même valeur.

Here, we use the tie breaker as the order of variable V3: by cell shape and by ID:
```{r, include=TRUE}
#arrange in the order of V2:cell size
biopsy_new<-arrange(biopsy_new,desc(cell_size),desc(cell_shape),ID)

head(biopsy_new,5)
```

## Summarize & Group By
** Summarize ** utilise les données pour créer un nouveau data frame  avec les statistiques récapitulatives telles que minimum, maximum, moyenne, etc. Ces fonctions statistiques doivent être des fonctions agrégées qui prennent un vecteur de valeurs en entrée et une valeur unique en sortie.

La fonction **group_by** regroupe les données en fonction des valeurs des variables. Ceci, en plus de summarize, fait de observations des groupes de lignes de l’ensemble de données.

Les médecins voudraient connaître la taille maximale de la cellule et son épaisseur pour chacune des classes: bénigne et maligne. Cela peut être fait en regroupant les données par classe et en recherchant le maximum de variables requises:
```{r, include=TRUE}
biopsy_grouped <- group_by(biopsy_new,class)
summarize(biopsy_grouped, max(thickness), mean(cell_size), var(norm_nucleoli))
```

## Pipe Operator
Que faire si nous voulons utiliser le différent data wrangling verbs **together**?

Cela pourrait être fait en sauvegardant le résultat de chaque wrangling function dans une nouvelle variable et en l'utilisant pour la fonction suivante, comme nous l'avons fait ci-dessus. Cependant, ceci n'est pas recommandé en tant que:

1. Cela nécessite une saisie supplémentaire et un code plus long.

2. L'espace inutile est utilisé pour sauvegarder les différentes variables. Si les données sont volumineuses, cette méthode ralentit l’analyse.

Le **pipe operator** peut être utilisé à la place pour le même but. L'opérateur est placé entre et objet et la fonction. Le pipe prend l'objet à sa gauche et le passe comme premier argument de la fonction à sa droite.

Le pipe operator fait partie du `magrittr` package. Cependant, ce package n'a pas besoin d'être chargé car le `dplyr` package simplifie la vie et importe le pipe operator pour nous:
```{r, include=TRUE}
biopsy_grouped <- biopsy_new %>% 
  group_by(class) %>% 
  summarize(max(thickness),mean(cell_size),var(norm_nucleoli))

head(biopsy_grouped)
```


## Tidying the transformed data

Have a look again at the messy data:

```{r, include=TRUE}
# Messy Data
head(biopsy_new,5)
```

La planification est nécessaire pour décider quelles colonnes nous devons garder inchangées, lesquelles modifier et quels noms doivent être donnés aux nouvelles colonnes. Les colonnes à conserver sont celles qui sont déjà en tidy. Les colonnes à modifier sont celles qui ne sont pas de vraies variables mais en réalité des niveaux d'une autre variable.

Donc, le `ID` et `class` columns sont déjà tidy. Ceux-ci sont conservés tels quels.

Les columns `V1:thickness`, `V2:cell_size`, `V3:cell_shape`, `V4:marg_adhesion`, `V5:epithelial_cell_size`, `V6:bare_nuclei`, et `V8:norm_nucleoli`  ne sont pas de vraies variables mais des valeurs de la variabl `Tumor_attributes`.

Nous pouvons résoudre ce problème avec `tidyr::gather()`, qui est utilisé pour convertir les données de messy en tidy. Le `gather` function prend le data frame que nous voulons tidy comme input. Les deux paramètres suivants sont les noms des colonnes key et value columns du tidy dataset.

Dans notre exemple, key = 'Tumor_Atrributes' et value = 'Score'. Vous pouvez également spécifier les colonnes que vous ne voulez pas ranger, à savoir ID et class:
```{r, include=TRUE}
#Tidy Data
library(tidyr)
tidy_df <- biopsy_new %>% gather(key = "Tumor_Attributes", value = "Score", -ID, -class)

tidy_df
```

## Liens utiles
- [r4ds on tidy data](https://r4ds.had.co.nz/tidy-data.html){target="_blank"}: C'est toujours mieux d'apprendre de la source, ainsi voici le livre écrit par Hadley Wickham.
- [DataCamp dplyr course](https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial){target="_blank"}: Ce cours couvre les différentes fonctions de dplyr et comment manipuler les données.

